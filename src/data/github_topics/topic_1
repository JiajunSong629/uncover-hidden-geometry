'use strict';

var clear          = require('es5-ext/array/#/clear')
  , eIndexOf       = require('es5-ext/array/#/e-index-of')
  , setPrototypeOf = require('es5-ext/object/set-prototype-of')
  , callable       = require('es5-ext/object/valid-callable')
  , d              = require('d')
  , ee             = require('event-emitter')
  , Symbol         = require('es6-symbol')
  , iterator       = require('es6-iterator/valid-iterable')
  , forOf          = require('es6-iterator/for-of')
  , Iterator       = require('./lib/iterator')
  , isNative       = require('./is-native-implemented')

  , call = Function.prototype.call, defineProperty = Object.defineProperty
  , SetPoly, getValues;

module.exports = SetPoly = function (/*iterable*/) {
	var iterable = arguments[0];
	if (!(this instanceof SetPoly)) return new SetPoly(iterable);
	if (this.__setData__ !== undefined) {
		throw new TypeError(this + " cannot be reinitialized");
	}
	if (iterable != null) iterator(iterable);
	defineProperty(this, '__setData__', d('c', []));
	if (!iterable) return;
	forOf(iterable, function (value) {
		if (eIndexOf.call(this, value) !== -1) return;
		this.push(value);
	}, this.__setData__);
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(SetPoly, Set);
	SetPoly.prototype = Object.create(Set.prototype, {
		constructor: d(SetPoly)
	});
}

ee(Object.defineProperties(SetPoly.prototype, {
	add: d(function (value) {
		if (this.has(value)) return this;
		this.emit('_add', this.__setData__.push(value) - 1, value);
		return this;
	}),
	clear: d(function () {
		if (!this.__setData__.length) return;
		clear.call(this.__setData__);
		this.emit('_clear');
	}),
	delete: d(function (value) {
		var index = eIndexOf.call(this.__setData__, value);
		if (index === -1) return false;
		this.__setData__.splice(index, 1);
		this.emit('_delete', index, value);
		return true;
	}),
	entries: d(function () { return new Iterator(this, 'key+value'); }),
	forEach: d(function (cb/*, thisArg*/) {
		var thisArg = arguments[1], iterator, result, value;
		callable(cb);
		iterator = this.values();
		result = iterator._next();
		while (result !== undefined) {
			value = iterator._resolve(result);
			call.call(cb, thisArg, value, value, this);
			result = iterator._next();
		}
	}),
	has: d(function (value) {
		return (eIndexOf.call(this.__setData__, value) !== -1);
	}),
	keys: d(getValues = function () { return this.values(); }),
	size: d.gs(function () { return this.__setData__.length; }),
	values: d(function () { return new Iterator(this); }),
	toString: d(function () { return '[object Set]'; })
}));
defineProperty(SetPoly.prototype, Symbol.iterator, d(getValues));
defineProperty(SetPoly.prototype, Symbol.toStringTag, d('c', 'Set'));

'use strict';

const TYPE = Symbol.for('type');

class Data {

  constructor(options) {
    // File details
    this.filepath = options.filepath;

    // Type
    this[TYPE] = 'data';

    // Data
    Object.assign(this, options.data);
  }
}

module.exports = Data;


function collectWithWildcard(test) {
	test.expect(4);

	var api_server = new Test_ApiServer(function handler(request, callback) {
		var url = request.url;

		switch (url) {
			case '/accounts?username=chariz*':
				let account = new Model_Account({
					username: 'charizard'
				});

				return void callback(null, [
					account.redact()
				]);

			default:
				let error = new Error('Invalid url: ' + url);

				return void callback(error);
		}
	});

	var parameters = {
		username: 'chariz*'
	};

	function handler(error, results) {
		test.equals(error, null);
		test.equals(results.length, 1);

		var account = results[0];

		test.equals(account.get('username'), 'charizard');
		test.equals(account.get('type'), Enum_AccountTypes.MEMBER);

		api_server.destroy();

		test.done();
	}

	Resource_Accounts.collect(parameters, handler);
}

module.exports = {
	collectWithWildcard
};

angular.module('appTesting').service("LoginLocalStorage", function () {
    "use strict";

    var STORE_NAME = "login";

    var setUser = function setUser(user) {
        localStorage.setItem(STORE_NAME, JSON.stringify(user));
    }

    var getUser = function getUser() {
        var storedTasks = localStorage.getItem(STORE_NAME);
        if (storedTasks) {
            return JSON.parse(storedTasks);
        }
        return {};
    }

    return {
        setUser: setUser,
        getUser: getUser
    }
});
// flow-typed signature: d37503430b92ad584be6e2c6f8d1fc08
// flow-typed version: <<STUB>>/ua-parser-js_v1.0.2/flow_v0.171.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'ua-parser-js'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

declare module 'ua-parser-js' {
  declare module.exports: any;
}

/**
 * We include stubs for each file inside this npm package in case you need to
 * require those files directly. Feel free to delete any files that aren't
 * needed.
 */
declare module 'ua-parser-js/dist/ua-parser.min' {
  declare module.exports: any;
}

declare module 'ua-parser-js/dist/ua-parser.pack' {
  declare module.exports: any;
}

declare module 'ua-parser-js/package' {
  declare module.exports: any;
}

declare module 'ua-parser-js/src/ua-parser' {
  declare module.exports: any;
}

declare module 'ua-parser-js/test/test' {
  declare module.exports: any;
}

// Filename aliases
declare module 'ua-parser-js/dist/ua-parser.min.js' {
  declare module.exports: $Exports<'ua-parser-js/dist/ua-parser.min'>;
}
declare module 'ua-parser-js/dist/ua-parser.pack.js' {
  declare module.exports: $Exports<'ua-parser-js/dist/ua-parser.pack'>;
}
declare module 'ua-parser-js/package.js' {
  declare module.exports: $Exports<'ua-parser-js/package'>;
}
declare module 'ua-parser-js/src/ua-parser.js' {
  declare module.exports: $Exports<'ua-parser-js/src/ua-parser'>;
}
declare module 'ua-parser-js/test/test.js' {
  declare module.exports: $Exports<'ua-parser-js/test/test'>;
}

/* eslint-disable no-console */
const buildData = require('./build_data');
const buildSrc = require('./build_src');
const buildCSS = require('./build_css');

let _currBuild = null;

// if called directly, do the thing.
buildAll();


function buildAll() {
  if (_currBuild) return _currBuild;

  return _currBuild =
    Promise.resolve()
    .then(() => buildCSS())
    .then(() => buildData())
    .then(() => buildSrc())
    .then(() => _currBuild = null)
    .catch((err) => {
      console.error(err);
      _currBuild = null;
      process.exit(1);
    });
}

module.exports = buildAll;

function LetterProps(o, sw, sc, fc, m, p) {
  this.o = o;
  this.sw = sw;
  this.sc = sc;
  this.fc = fc;
  this.m = m;
  this.p = p;
  this._mdf = {
    o: true,
    sw: !!sw,
    sc: !!sc,
    fc: !!fc,
    m: true,
    p: true,
  };
}

LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
  this._mdf.o = false;
  this._mdf.sw = false;
  this._mdf.sc = false;
  this._mdf.fc = false;
  this._mdf.m = false;
  this._mdf.p = false;
  var updated = false;

  if (this.o !== o) {
    this.o = o;
    this._mdf.o = true;
    updated = true;
  }
  if (this.sw !== sw) {
    this.sw = sw;
    this._mdf.sw = true;
    updated = true;
  }
  if (this.sc !== sc) {
    this.sc = sc;
    this._mdf.sc = true;
    updated = true;
  }
  if (this.fc !== fc) {
    this.fc = fc;
    this._mdf.fc = true;
    updated = true;
  }
  if (this.m !== m) {
    this.m = m;
    this._mdf.m = true;
    updated = true;
  }
  if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
    this.p = p;
    this._mdf.p = true;
    updated = true;
  }
  return updated;
};

System.register(["angular2/test_lib", "angular2/src/test_lib/test_bed", "angular2/src/core/annotations_impl/annotations", "angular2/src/core/annotations_impl/view", "angular2/src/core/compiler/dynamic_component_loader", "angular2/src/core/compiler/element_ref", "angular2/src/directives/if", "angular2/src/render/dom/direct_dom_renderer", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var AsyncTestCompleter,
      beforeEach,
      ddescribe,
      xdescribe,
      describe,
      el,
      dispatchEvent,
      expect,
      iit,
      inject,
      beforeEachBindings,
      it,
      xit,
      TestBed,
      Component,
      View,
      DynamicComponentLoader,
      ElementRef,
      If,
      DirectDomRenderer,
      DOM,
      ImperativeViewComponentUsingNgComponent,
      ChildComp,
      DynamicallyCreatedComponentService,
      DynamicComp,
      DynamicallyCreatedCmp,
      DynamicallyLoaded,
      DynamicallyLoaded2,
      DynamicallyLoadedWithHostProps,
      Location,
      MyComp;
  function main() {
    describe('DynamicComponentLoader', function() {
      describe("loading into existing location", (function() {
        it('should work', inject([TestBed, AsyncTestCompleter], (function(tb, async) {
          tb.overrideView(MyComp, new View({
            template: '<dynamic-comp #dynamic></dynamic-comp>',
            directives: [DynamicComp]
          }));
          tb.createView(MyComp).then((function(view) {
            var dynamicComponent = view.rawView.locals.get("dynamic");
            expect(dynamicComponent).toBeAnInstanceOf(DynamicComp);
            dynamicComponent.done.then((function(_) {
              view.detectChanges();
              expect(view.rootNodes).toHaveText('hello');
              async.done();
            }));
          }));
        })));
        it('should inject dependencies of the dynamically-loaded component', inject([TestBed, AsyncTestCompleter], (function(tb, async) {
          tb.overrideView(MyComp, new View({
            template: '<dynamic-comp #dynamic></dynamic-comp>',
            directives: [DynamicComp]
          }));
          tb.createView(MyComp).then((function(view) {
            var dynamicComponent = view.rawView.locals.get("dynamic");
            dynamicComponent.done.then((function(ref) {
              expect(ref.instance.dynamicallyCreatedComponentService).toBeAnInstanceOf(DynamicallyCreatedComponentService);
              async.done();
            }));
          }));
        })));
        it('should allow to destroy and create them via viewcontainer directives', inject([TestBed, AsyncTestCompleter], (function(tb, async) {
          tb.overrideView(MyComp, new View({
            template: '<div><dynamic-comp #dynamic template="if: ctxBoolProp"></dynamic-comp></div>',
            directives: [DynamicComp, If]
          }));
          tb.createView(MyComp).then((function(view) {
            view.context.ctxBoolProp = true;
            view.detectChanges();
            var dynamicComponent = view.rawView.viewContainers[0].views[0].locals.get("dynamic");
            dynamicComponent.done.then((function(_) {
              view.detectChanges();
              expect(view.rootNodes).toHaveText('hello');
              view.context.ctxBoolProp = false;
              view.detectChanges();
              expect(view.rawView.viewContainers[0].views.length).toBe(0);
              expect(view.rootNodes).toHaveText('');
              view.context.ctxBoolProp = true;
              view.detectChanges();
              var dynamicComponent = view.rawView.viewContainers[0].views[0].locals.get("dynamic");
              return dynamicComponent.done;
            })).then((function(_) {
              view.detectChanges();
              expect(view.rootNodes).toHaveText('hello');
              async.done();
            }));
          }));
        })));
      }));
      describe("loading next to an existing location", (function() {
        it('should work', inject([DynamicComponentLoader, TestBed, AsyncTestCompleter], (function(loader, tb, async) {
          tb.overrideView(MyComp, new View({
            template: '<div><location #loc></location></div>',
            directives: [Location]
          }));
          tb.createView(MyComp).then((function(view) {
            var location = view.rawView.locals.get("loc");
            loader.loadNextToExistingLocation(DynamicallyLoaded, location.elementRef).then((function(ref) {
              expect(view.rootNodes).toHaveText("Location;DynamicallyLoaded;");
              async.done();
            }));
          }));
        })));
        it('should return a disposable component ref', inject([DynamicComponentLoader, TestBed, AsyncTestCompleter], (function(loader, tb, async) {
          tb.overrideView(MyComp, new View({
            template: '<div><location #loc></location></div>',
            directives: [Location]
          }));
          tb.createView(MyComp).then((function(view) {
            var location = view.rawView.locals.get("loc");
            loader.loadNextToExistingLocation(DynamicallyLoaded, location.elementRef).then((function(ref) {
              loader.loadNextToExistingLocation(DynamicallyLoaded2, location.elementRef).then((function(ref2) {
                expect(view.rootNodes).toHaveText("Location;DynamicallyLoaded;DynamicallyLoaded2;");
                ref2.dispose();
                expect(view.rootNodes).toHaveText("Location;DynamicallyLoaded;");
                async.done();
              }));
            }));
          }));
        })));
        it('should update host properties', inject([DynamicComponentLoader, TestBed, AsyncTestCompleter], (function(loader, tb, async) {
          tb.overrideView(MyComp, new View({
            template: '<div><location #loc></location></div>',
            directives: [Location]
          }));
          tb.createView(MyComp).then((function(view) {
            var location = view.rawView.locals.get("loc");
            loader.loadNextToExistingLocation(DynamicallyLoadedWithHostProps, location.elementRef).then((function(ref) {
              ref.instance.id = "new value";
              view.detectChanges();
              var newlyInsertedElement = DOM.childNodesAsList(view.rootNodes[0])[1];
              expect(newlyInsertedElement.id).toEqual("new value");
              async.done();
            }));
          }));
        })));
      }));
      describe('loading into a new location', (function() {
        it('should allow to create, update and destroy components', inject([TestBed, AsyncTestCompleter], (function(tb, async) {
          tb.overrideView(MyComp, new View({
            template: '<imp-ng-cmp #impview></imp-ng-cmp>',
            directives: [ImperativeViewComponentUsingNgComponent]
          }));
          tb.createView(MyComp).then((function(view) {
            var userViewComponent = view.rawView.locals.get("impview");
            userViewComponent.done.then((function(childComponentRef) {
              view.detectChanges();
              expect(view.rootNodes).toHaveText('hello');
              childComponentRef.instance.ctxProp = 'new';
              view.detectChanges();
              expect(view.rootNodes).toHaveText('new');
              childComponentRef.dispose();
              expect(view.rootNodes).toHaveText('');
              async.done();
            }));
          }));
        })));
      }));
    });
  }
  $__export("main", main);
  return {
    setters: [function($__m) {
      AsyncTestCompleter = $__m.AsyncTestCompleter;
      beforeEach = $__m.beforeEach;
      ddescribe = $__m.ddescribe;
      xdescribe = $__m.xdescribe;
      describe = $__m.describe;
      el = $__m.el;
      dispatchEvent = $__m.dispatchEvent;
      expect = $__m.expect;
      iit = $__m.iit;
      inject = $__m.inject;
      beforeEachBindings = $__m.beforeEachBindings;
      it = $__m.it;
      xit = $__m.xit;
    }, function($__m) {
      TestBed = $__m.TestBed;
    }, function($__m) {
      Component = $__m.Component;
    }, function($__m) {
      View = $__m.View;
    }, function($__m) {
      DynamicComponentLoader = $__m.DynamicComponentLoader;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      If = $__m.If;
    }, function($__m) {
      DirectDomRenderer = $__m.DirectDomRenderer;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      ImperativeViewComponentUsingNgComponent = (function() {
        var ImperativeViewComponentUsingNgComponent = function ImperativeViewComponentUsingNgComponent(self, dynamicComponentLoader, renderer) {
          var div = el('<div></div>');
          renderer.setImperativeComponentRootNodes(self.parentView.render, self.boundElementIndex, [div]);
          this.done = dynamicComponentLoader.loadIntoNewLocation(ChildComp, self, div, null);
        };
        return ($traceurRuntime.createClass)(ImperativeViewComponentUsingNgComponent, {}, {});
      }());
      Object.defineProperty(ImperativeViewComponentUsingNgComponent, "annotations", {get: function() {
          return [new Component({selector: 'imp-ng-cmp'}), new View({renderer: 'imp-ng-cmp-renderer'})];
        }});
      Object.defineProperty(ImperativeViewComponentUsingNgComponent, "parameters", {get: function() {
          return [[ElementRef], [DynamicComponentLoader], [DirectDomRenderer]];
        }});
      ChildComp = (function() {
        var ChildComp = function ChildComp() {
          this.ctxProp = 'hello';
        };
        return ($traceurRuntime.createClass)(ChildComp, {}, {});
      }());
      Object.defineProperty(ChildComp, "annotations", {get: function() {
          return [new Component({selector: 'child-cmp'}), new View({template: '{{ctxProp}}'})];
        }});
      DynamicallyCreatedComponentService = (function() {
        var DynamicallyCreatedComponentService = function DynamicallyCreatedComponentService() {
          ;
        };
        return ($traceurRuntime.createClass)(DynamicallyCreatedComponentService, {}, {});
      }());
      DynamicComp = (function() {
        var DynamicComp = function DynamicComp(loader, location) {
          this.done = loader.loadIntoExistingLocation(DynamicallyCreatedCmp, location);
        };
        return ($traceurRuntime.createClass)(DynamicComp, {}, {});
      }());
      Object.defineProperty(DynamicComp, "annotations", {get: function() {
          return [new Component({selector: 'dynamic-comp'})];
        }});
      Object.defineProperty(DynamicComp, "parameters", {get: function() {
          return [[DynamicComponentLoader], [ElementRef]];
        }});
      DynamicallyCreatedCmp = (function() {
        var DynamicallyCreatedCmp = function DynamicallyCreatedCmp(a) {
          this.greeting = "hello";
          this.dynamicallyCreatedComponentService = a;
        };
        return ($traceurRuntime.createClass)(DynamicallyCreatedCmp, {}, {});
      }());
      Object.defineProperty(DynamicallyCreatedCmp, "annotations", {get: function() {
          return [new Component({
            selector: 'hello-cmp',
            injectables: [DynamicallyCreatedComponentService]
          }), new View({template: "{{greeting}}"})];
        }});
      Object.defineProperty(DynamicallyCreatedCmp, "parameters", {get: function() {
          return [[DynamicallyCreatedComponentService]];
        }});
      DynamicallyLoaded = (function() {
        var DynamicallyLoaded = function DynamicallyLoaded() {
          ;
        };
        return ($traceurRuntime.createClass)(DynamicallyLoaded, {}, {});
      }());
      Object.defineProperty(DynamicallyLoaded, "annotations", {get: function() {
          return [new Component({selector: 'dummy'}), new View({template: "DynamicallyLoaded;"})];
        }});
      DynamicallyLoaded2 = (function() {
        var DynamicallyLoaded2 = function DynamicallyLoaded2() {
          ;
        };
        return ($traceurRuntime.createClass)(DynamicallyLoaded2, {}, {});
      }());
      Object.defineProperty(DynamicallyLoaded2, "annotations", {get: function() {
          return [new Component({selector: 'dummy'}), new View({template: "DynamicallyLoaded2;"})];
        }});
      DynamicallyLoadedWithHostProps = (function() {
        var DynamicallyLoadedWithHostProps = function DynamicallyLoadedWithHostProps() {
          this.id = "default";
        };
        return ($traceurRuntime.createClass)(DynamicallyLoadedWithHostProps, {}, {});
      }());
      Object.defineProperty(DynamicallyLoadedWithHostProps, "annotations", {get: function() {
          return [new Component({
            selector: 'dummy',
            hostProperties: {'id': 'id'}
          }), new View({template: "DynamicallyLoadedWithHostProps;"})];
        }});
      Location = (function() {
        var Location = function Location(elementRef) {
          this.elementRef = elementRef;
        };
        return ($traceurRuntime.createClass)(Location, {}, {});
      }());
      Object.defineProperty(Location, "annotations", {get: function() {
          return [new Component({selector: 'location'}), new View({template: "Location;"})];
        }});
      Object.defineProperty(Location, "parameters", {get: function() {
          return [[ElementRef]];
        }});
      MyComp = (function() {
        var MyComp = function MyComp() {
          this.ctxBoolProp = false;
        };
        return ($traceurRuntime.createClass)(MyComp, {}, {});
      }());
      Object.defineProperty(MyComp, "annotations", {get: function() {
          return [new Component({selector: 'my-comp'}), new View({directives: []})];
        }});
    }
  };
});
//# sourceMappingURL=dynamic_component_loader_spec.es6.map

//# sourceMappingURL=./dynamic_component_loader_spec.js.map
// The following are instance methods and variables
var Note = Class.create({
  initialize: function(id, is_new, raw_body) {
    if (Note.debug) {
      console.debug("Note#initialize (id=%d)", id)
    }

    this.id = id
    this.is_new = is_new
    this.document_observers = [];

    // Cache the elements
    this.elements = {
      box: $('note-box-' + this.id),
      corner: $('note-corner-' + this.id),
      body: $('note-body-' + this.id),
      image: $('image')
    }

    // Cache the dimensions
    this.fullsize = {
      left: this.elements.box.offsetLeft,
      top: this.elements.box.offsetTop,
      width: this.elements.box.clientWidth,
      height: this.elements.box.clientHeight
    }

    // Store the original values (in case the user clicks Cancel)
    this.old = {
      raw_body: raw_body,
      formatted_body: this.elements.body.innerHTML
    }
    for (p in this.fullsize) {
      this.old[p] = this.fullsize[p]
    }

    // Make the note translucent
    if (is_new) {
      this.elements.box.setOpacity(0.2)
    } else {
      this.elements.box.setOpacity(0.5)
    }

    if (is_new && raw_body == '') {
      this.bodyfit = true
      this.elements.body.style.height = "100px"
    }

    // Attach the event listeners
    this.elements.box.observe("mousedown", this.dragStart.bindAsEventListener(this))
    this.elements.box.observe("mouseout", this.bodyHideTimer.bindAsEventListener(this))
    this.elements.box.observe("mouseover", this.bodyShow.bindAsEventListener(this))
    this.elements.corner.observe("mousedown", this.resizeStart.bindAsEventListener(this))
    this.elements.body.observe("mouseover", this.bodyShow.bindAsEventListener(this))
    this.elements.body.observe("mouseout", this.bodyHideTimer.bindAsEventListener(this))
    this.elements.body.observe("click", this.showEditBox.bindAsEventListener(this))

    this.adjustScale()
  },

  // Returns the raw text value of this note
  textValue: function() {
    if (Note.debug) {
      console.debug("Note#textValue (id=%d)", this.id)
    }

    return this.old.raw_body.strip()
  },

  // Removes the edit box
  hideEditBox: function(e) {
    if (Note.debug) {
      console.debug("Note#hideEditBox (id=%d)", this.id)
    }

    var editBox = $('edit-box')

    if (editBox != null) {
      var boxid = editBox.noteid

      $("edit-box").stopObserving()
      $("note-save-" + boxid).stopObserving()
      $("note-cancel-" + boxid).stopObserving()
      $("note-remove-" + boxid).stopObserving()
      $("note-history-" + boxid).stopObserving()
      $("edit-box").remove()
    }
  },

  // Shows the edit box
  showEditBox: function(e) {
    if (Note.debug) {
      console.debug("Note#showEditBox (id=%d)", this.id)
    }

    this.hideEditBox(e)

    var insertionPosition = Note.getInsertionPosition()
    var top = insertionPosition[0]
    var left = insertionPosition[1]
    var html = ""

    html += '<div id="edit-box" style="top: '+top+'px; left: '+left+'px; position: absolute; visibility: visible; z-index: 100; background: white; border: 1px solid black; padding: 12px;">'
    html += '<form onsubmit="return false;" style="padding: 0; margin: 0;">'
    html += '<textarea rows="7" id="edit-box-text" style="width: 350px; margin: 2px 2px 12px 2px;">' + this.textValue() + '</textarea>'
    html += '<input type="submit" value="Save" name="save" id="note-save-' + this.id + '">'
    html += '<input type="submit" value="Cancel" name="cancel" id="note-cancel-' + this.id + '">'
    html += '<input type="submit" value="Remove" name="remove" id="note-remove-' + this.id + '">'
    html += '<input type="submit" value="History" name="history" id="note-history-' + this.id + '">'
    html += '</form>'
    html += '</div>'

    $("note-container").insert({bottom: html})
    $('edit-box').noteid = this.id
    $("edit-box").observe("mousedown", this.editDragStart.bindAsEventListener(this))
    $("note-save-" + this.id).observe("click", this.save.bindAsEventListener(this))
    $("note-cancel-" + this.id).observe("click", this.cancel.bindAsEventListener(this))
    $("note-remove-" + this.id).observe("click", this.remove.bindAsEventListener(this))
    $("note-history-" + this.id).observe("click", this.history.bindAsEventListener(this))
    $("edit-box-text").focus()
  },

  // Shows the body text for the note
  bodyShow: function(e) {
    if (Note.debug) {
      console.debug("Note#bodyShow (id=%d)", this.id)
    }

    if (this.dragging) {
      return
    }

    if (this.hideTimer) {
      clearTimeout(this.hideTimer)
      this.hideTimer = null
    }

    if (Note.noteShowingBody == this) {
      return
    }

    if (Note.noteShowingBody) {
      Note.noteShowingBody.bodyHide()
    }

    Note.noteShowingBody = this

    if (Note.zindex >= 9) {
      /* don't use more than 10 layers (+1 for the body, which will always be above all notes) */
      Note.zindex = 0
      for (var i=0; i< Note.all.length; ++i) {
        Note.all[i].elements.box.style.zIndex = 0
      }
    }

    this.elements.box.style.zIndex = ++Note.zindex
    this.elements.body.style.zIndex = 10
    this.elements.body.style.top = 0 + "px"
    this.elements.body.style.left = 0 + "px"

    var dw = document.documentElement.scrollWidth
    this.elements.body.style.visibility = "hidden"
    this.elements.body.style.display = "block"
    if (!this.bodyfit) {
      this.elements.body.style.height = "auto"
      this.elements.body.style.minWidth = "140px"
      var w = null, h = null, lo = null, hi = null, x = null, last = null
      w = this.elements.body.offsetWidth
      h = this.elements.body.offsetHeight
      if (w/h < 1.6180339887) {
        /* for tall notes (lots of text), find more pleasant proportions */
        lo = 140, hi = 400
        do {
          last = w
          x = (lo+hi)/2
          this.elements.body.style.minWidth = x + "px"
          w = this.elements.body.offsetWidth
          h = this.elements.body.offsetHeight
          if (w/h < 1.6180339887) lo = x
          else hi = x
        } while ((lo < hi) && (w > last))
      } else if (this.elements.body.scrollWidth <= this.elements.body.clientWidth) {
        /* for short notes (often a single line), make the box no wider than necessary */
        // scroll test necessary for Firefox
        lo = 20, hi = w

        do {
          x = (lo+hi)/2
          this.elements.body.style.minWidth = x + "px"
          if (this.elements.body.offsetHeight > h) lo = x
          else hi = x
        } while ((hi - lo) > 4)
        if (this.elements.body.offsetHeight > h)
          this.elements.body.style.minWidth = hi + "px"
      }

      if (Prototype.Browser.IE) {
        // IE7 adds scrollbars if the box is too small, obscuring the text
        if (this.elements.body.offsetHeight < 35) {
          this.elements.body.style.minHeight = "35px"
        }

        if (this.elements.body.offsetWidth < 47) {
          this.elements.body.style.minWidth = "47px"
        }
      }
      this.bodyfit = true
    }
    this.elements.body.style.top = (this.elements.box.offsetTop + this.elements.box.clientHeight + 5) + "px"
    // keep the box within the document's width
    var l = 0, e = this.elements.box
    do { l += e.offsetLeft } while (e = e.offsetParent)
    l += this.elements.body.offsetWidth + 10 - dw
    if (l > 0)
      this.elements.body.style.left = this.elements.box.offsetLeft - l + "px"
    else
      this.elements.body.style.left = this.elements.box.offsetLeft + "px"
    this.elements.body.style.visibility = "visible"
  },

  // Creates a timer that will hide the body text for the note
  bodyHideTimer: function(e) {
    if (Note.debug) {
      console.debug("Note#bodyHideTimer (id=%d)", this.id)
    }
    this.hideTimer = setTimeout(this.bodyHide.bindAsEventListener(this), 250)
  },

  // Hides the body text for the note
  bodyHide: function(e) {
    if (Note.debug) {
      console.debug("Note#bodyHide (id=%d)", this.id)
    }

    this.elements.body.hide()
    if (Note.noteShowingBody == this) {
      Note.noteShowingBody = null
    }
  },

  addDocumentObserver: function(name, func)
  {
    document.observe(name, func);
    this.document_observers.push([name, func]);
  },

  clearDocumentObservers: function(name, handler)
  {
    for(var i = 0; i < this.document_observers.length; ++i)
    {
      var observer = this.document_observers[i];
      document.stopObserving(observer[0], observer[1]);
    }

    this.document_observers = [];
  },

  // Start dragging the note
  dragStart: function(e) {
    if (Note.debug) {
      console.debug("Note#dragStart (id=%d)", this.id)
    }

    this.addDocumentObserver("mousemove", this.drag.bindAsEventListener(this))
    this.addDocumentObserver("mouseup", this.dragStop.bindAsEventListener(this))
    this.addDocumentObserver("selectstart", function() {return false})

    this.cursorStartX = e.pointerX()
    this.cursorStartY = e.pointerY()
    this.boxStartX = this.elements.box.offsetLeft
    this.boxStartY = this.elements.box.offsetTop
    this.boundsX = new ClipRange(5, this.elements.image.clientWidth - this.elements.box.clientWidth - 5)
    this.boundsY = new ClipRange(5, this.elements.image.clientHeight - this.elements.box.clientHeight - 5)
    this.dragging = true
    this.bodyHide()
  },

  // Stop dragging the note
  dragStop: function(e) {
    if (Note.debug) {
      console.debug("Note#dragStop (id=%d)", this.id)
    }

    this.clearDocumentObservers()

    this.cursorStartX = null
    this.cursorStartY = null
    this.boxStartX = null
    this.boxStartY = null
    this.boundsX = null
    this.boundsY = null
    this.dragging = false

    this.bodyShow()
  },

  ratio: function() {
    return this.elements.image.width / this.elements.image.getAttribute("large_width")
    // var ratio = this.elements.image.width / this.elements.image.getAttribute("large_width")
    // if (this.elements.image.scale_factor != null)
      // ratio *= this.elements.image.scale_factor;
    // return ratio
  },

  // Scale the notes for when the image gets resized
  adjustScale: function() {
    if (Note.debug) {
      console.debug("Note#adjustScale (id=%d)", this.id)
    }

    var ratio = this.ratio()
    for (p in this.fullsize) {
      this.elements.box.style[p] = this.fullsize[p] * ratio + 'px'
    }
  },

  // Update the note's position as it gets dragged
  drag: function(e) {
    var left = this.boxStartX + e.pointerX() - this.cursorStartX
    var top = this.boxStartY + e.pointerY() - this.cursorStartY
    left = this.boundsX.clip(left)
    top = this.boundsY.clip(top)

    this.elements.box.style.left = left + 'px'
    this.elements.box.style.top = top + 'px'
    var ratio = this.ratio()
    this.fullsize.left = left / ratio
    this.fullsize.top = top / ratio

    e.stop()
  },

  // Start dragging the edit box
  editDragStart: function(e) {
    if (Note.debug) {
      console.debug("Note#editDragStart (id=%d)", this.id)
    }

    var node = e.element().nodeName
    if (node != 'FORM' && node != 'DIV') {
      return
    }

    this.addDocumentObserver("mousemove", this.editDrag.bindAsEventListener(this))
    this.addDocumentObserver("mouseup", this.editDragStop.bindAsEventListener(this))
    this.addDocumentObserver("selectstart", function() {return false})

    this.elements.editBox = $('edit-box');
    this.cursorStartX = e.pointerX()
    this.cursorStartY = e.pointerY()
    this.editStartX = this.elements.editBox.offsetLeft
    this.editStartY = this.elements.editBox.offsetTop
    this.dragging = true
  },

  // Stop dragging the edit box
  editDragStop: function(e) {
    if (Note.debug) {
      console.debug("Note#editDragStop (id=%d)", this.id)
    }
    this.clearDocumentObservers()

    this.cursorStartX = null
    this.cursorStartY = null
    this.editStartX = null
    this.editStartY = null
    this.dragging = false
  },

  // Update the edit box's position as it gets dragged
  editDrag: function(e) {
    var left = this.editStartX + e.pointerX() - this.cursorStartX
    var top = this.editStartY + e.pointerY() - this.cursorStartY

    this.elements.editBox.style.left = left + 'px'
    this.elements.editBox.style.top = top + 'px'

    e.stop()
  },

  // Start resizing the note
  resizeStart: function(e) {
    if (Note.debug) {
      console.debug("Note#resizeStart (id=%d)", this.id)
    }

    this.cursorStartX = e.pointerX()
    this.cursorStartY = e.pointerY()
    this.boxStartWidth = this.elements.box.clientWidth
    this.boxStartHeight = this.elements.box.clientHeight
    this.boxStartX = this.elements.box.offsetLeft
    this.boxStartY = this.elements.box.offsetTop
    this.boundsX = new ClipRange(10, this.elements.image.clientWidth - this.boxStartX - 5)
    this.boundsY = new ClipRange(10, this.elements.image.clientHeight - this.boxStartY - 5)
    this.dragging = true

    this.clearDocumentObservers()
    this.addDocumentObserver("mousemove", this.resize.bindAsEventListener(this))
    this.addDocumentObserver("mouseup", this.resizeStop.bindAsEventListener(this))

    e.stop()
    this.bodyHide()
  },

  // Stop resizing teh note
  resizeStop: function(e) {
    if (Note.debug) {
      console.debug("Note#resizeStop (id=%d)", this.id)
    }

    this.clearDocumentObservers()

    this.boxCursorStartX = null
    this.boxCursorStartY = null
    this.boxStartWidth = null
    this.boxStartHeight = null
    this.boxStartX = null
    this.boxStartY = null
    this.boundsX = null
    this.boundsY = null
    this.dragging = false

    e.stop()
  },

  // Update the note's dimensions as it gets resized
  resize: function(e) {
    var width = this.boxStartWidth + e.pointerX() - this.cursorStartX
    var height = this.boxStartHeight + e.pointerY() - this.cursorStartY
    width = this.boundsX.clip(width)
    height = this.boundsY.clip(height)

    this.elements.box.style.width = width + "px"
    this.elements.box.style.height = height + "px"
    var ratio = this.ratio()
    this.fullsize.width = width / ratio
    this.fullsize.height = height / ratio

    e.stop()
  },

  // Save the note to the database
  save: function(e) {
    if (Note.debug) {
      console.debug("Note#save (id=%d)", this.id)
    }

    var note = this
    for (p in this.fullsize) {
      this.old[p] = this.fullsize[p]
    }
    this.old.raw_body = $('edit-box-text').value
    this.old.formatted_body = this.textValue()
    // FIXME: this is not quite how the note will look (filtered elems, <tn>...). the user won't input a <script> that only damages him, but it might be nice to "preview" the <tn> here
    this.elements.body.update(this.textValue())

    this.hideEditBox(e)
    this.bodyHide()
    this.bodyfit = false

    var params = {
      "id": this.id,
      "note[x]": this.old.left,
      "note[y]": this.old.top,
      "note[width]": this.old.width,
      "note[height]": this.old.height,
      "note[body]": this.old.raw_body
    }

    if (this.is_new) {
      params["note[post_id]"] = Note.post_id
    }

    notice("Saving note...")

    new Ajax.Request('/note/update.json', {
      parameters: params,

      onComplete: function(resp) {
        var resp = resp.responseJSON

        if (resp.success) {
          notice("Note saved")
          var note = Note.find(resp.old_id)

          if (resp.old_id < 0) {
            note.is_new = false
            note.id = resp.new_id
            note.elements.box.id = 'note-box-' + note.id
            note.elements.body.id = 'note-body-' + note.id
            note.elements.corner.id = 'note-corner-' + note.id
          }
          note.elements.body.innerHTML = resp.formatted_body
          note.elements.box.setOpacity(0.5)
          note.elements.box.removeClassName('unsaved')
        } else {
          notice("Error: " + resp.reason)
          note.elements.box.addClassName('unsaved')
        }
      }
    })

    e.stop()
  },

  // Revert the note to the last saved state
  cancel: function(e) {
    if (Note.debug) {
      console.debug("Note#cancel (id=%d)", this.id)
    }

    this.hideEditBox(e)
    this.bodyHide()

    var ratio = this.ratio()
    for (p in this.fullsize) {
      this.fullsize[p] = this.old[p]
      this.elements.box.style[p] = this.fullsize[p] * ratio + 'px'
    }
    this.elements.body.innerHTML = this.old.formatted_body

    e.stop()
  },

  // Remove all references to the note from the page
  removeCleanup: function() {
    if (Note.debug) {
      console.debug("Note#removeCleanup (id=%d)", this.id)
    }

    this.elements.box.remove()
    this.elements.body.remove()

    var allTemp = []
    for (i=0; i<Note.all.length; ++i) {
      if (Note.all[i].id != this.id) {
        allTemp.push(Note.all[i])
      }
    }

    Note.all = allTemp
    Note.updateNoteCount()
  },

  // Removes a note from the database
  remove: function(e) {
    if (Note.debug) {
      console.debug("Note#remove (id=%d)", this.id)
    }

    this.hideEditBox(e)
    this.bodyHide()
    this_note = this

    if (this.is_new) {
      this.removeCleanup()
      notice("Note removed")

    } else {
      notice("Removing note...")

      new Ajax.Request('/note/update.json', {
        parameters: {
          "id": this.id,
          "note[is_active]": "0"
        },
        onComplete: function(resp) {
          var resp = resp.responseJSON

          if (resp.success) {
            notice("Note removed")
            this_note.removeCleanup()
          } else {
            notice("Error: " + resp.reason)
          }
        }
      })
    }

    e.stop()
  },

  // Redirect to the note's history
  history: function(e) {
    if (Note.debug) {
      console.debug("Note#history (id=%d)", this.id)
    }

    this.hideEditBox(e)

    if (this.is_new) {
      notice("This note has no history")
    } else {
      location.href = '/history?search=notes:' + this.id
    }

    e.stop()
  }
})

// The following are class methods and variables
Object.extend(Note, {
  zindex: 0,
  counter: -1,
  all: [],
  display: true,
  debug: false,

  // Show all notes
  show: function() {
    if (Note.debug) {
      console.debug("Note.show")
    }

    $("note-container").show()
  },

  // Hide all notes
  hide: function() {
    if (Note.debug) {
      console.debug("Note.hide")
    }

    $("note-container").hide()
  },

  // Find a note instance based on the id number
  find: function(id) {
    if (Note.debug) {
      console.debug("Note.find")
    }

    for (var i=0; i<Note.all.size(); ++i) {
      if (Note.all[i].id == id) {
        return Note.all[i]
      }
    }

    return null
  },

  // Toggle the display of all notes
  toggle: function() {
    if (Note.debug) {
      console.debug("Note.toggle")
    }

    if (Note.display) {
      Note.hide()
      Note.display = false
    } else {
      Note.show()
      Note.display = true
    }
  },

  // Update the text displaying the number of notes a post has
  updateNoteCount: function() {
    if (Note.debug) {
      console.debug("Note.updateNoteCount")
    }

    if (Note.all.length > 0) {
      var label = ""

      if (Note.all.length == 1)
        label = "note"
      else
        label = "notes"

      $('note-count').innerHTML = "This post has <a href=\"/note/history?post_id=" + Note.post_id + "\">" + Note.all.length + " " + label + "</a>"
    } else {
      $('note-count').innerHTML = ""
    }
  },

  // Create a new note
  create: function() {
    if (Note.debug) {
      console.debug("Note.create")
    }

		Note.show()

    var insertion_position = Note.getInsertionPosition()
    var top = insertion_position[0]
    var left = insertion_position[1]
    var html = ''
    html += '<div class="note-box unsaved" style="width: 150px; height: 150px; '
    html += 'top: ' + top + 'px; '
    html += 'left: ' + left + 'px;" '
    html += 'id="note-box-' + Note.counter + '">'
    html += '<div class="note-corner" id="note-corner-' + Note.counter + '"></div>'
    html += '</div>'
    html += '<div class="note-body" title="Click to edit" id="note-body-' + Note.counter + '"></div>'
    $("note-container").insert({bottom: html})
    var note = new Note(Note.counter, true, "")
    Note.all.push(note)
    Note.counter -= 1
  },

  // Find a suitable position to insert new notes
  getInsertionPosition: function() {
    if (Note.debug) {
      console.debug("Note.getInsertionPosition")
    }

    // We want to show the edit box somewhere on the screen, but not outside the image.
    var scroll_x = $("image").cumulativeScrollOffset()[0]
    var scroll_y = $("image").cumulativeScrollOffset()[1]
    var image_left = $("image").positionedOffset()[0]
    var image_top = $("image").positionedOffset()[1]
    var image_right = image_left + $("image").width
    var image_bottom = image_top + $("image").height
    var left = 0
    var top = 0

    if (scroll_x > image_left) {
      left = scroll_x
    } else {
      left = image_left
    }

    if (scroll_y > image_top) {
      top = scroll_y
    } else {
      top = image_top + 20
    }

    if (top > image_bottom) {
      top = image_top + 20
    }

    return [top, left]
  }
})

describe('dJSON', function () {
  'use strict';

  var chai = require('chai');
  var expect = chai.expect;

  var dJSON = require('../lib/dJSON');

  var path = 'x.y["q.{r}"].z';
  var obj;
  beforeEach(function () {
    obj = {
      x: {
        y: {
          'q.{r}': {
            z: 635
          },
          q: {
            r: {
              z: 1
            }
          }
        }
      },
      'x-y': 5,
      falsy: false
    };
  });
  it('gets a value from an object with a path containing properties which contain a period', function () {
    expect(dJSON.get(obj, path)).to.equal(635);
    expect(dJSON.get(obj, 'x.y.q.r.z')).to.equal(1);
  });

  it('sets a value from an object with a path containing properties which contain a period', function () {
    dJSON.set(obj, path, 17771);
    expect(dJSON.get(obj, path)).to.equal(17771);
    expect(dJSON.get(obj, 'x.y.q.r.z')).to.equal(1);
  });

  it('will return undefined when requesting a property with a dash directly', function () {
    expect(dJSON.get(obj, 'x-y')).to.be.undefined;
  });

  it('will return the proper value when requesting a property with a dash by square bracket notation', function () {
    expect(dJSON.get(obj, '["x-y"]')).to.equal(5);
  });

  it('returns a value that is falsy', function () {
    expect(dJSON.get(obj, 'falsy')).to.equal(false);
  });

  it('sets a value that is falsy', function () {
    dJSON.set(obj, 'new', false);
    expect(dJSON.get(obj, 'new')).to.equal(false);
  });

  it('uses an empty object as default for the value in the set method', function () {
    var newObj = {};
    dJSON.set(newObj, 'foo.bar.lorem');
    expect(newObj).to.deep.equal({
      foo: {
        bar: {
          lorem: {}
        }
      }
    });
  });

  it('does not create an object when a path exists as empty string', function () {
    var newObj = {
      nestedObject: {
        anArray: [
          'i have a value',
          ''
        ]
      }
    };
    var newPath = 'nestedObject.anArray[1]';

    dJSON.set(newObj, newPath, 17771);
    expect(newObj).to.deep.equal({
      nestedObject: {
        anArray: [
          'i have a value',
          17771
        ]
      }
    });
  });

  it('creates an object from a path with a left curly brace', function () {
    var newObj = {};

    dJSON.set(newObj, path.replace('}', ''), 'foo');
    expect(newObj).to.be.deep.equal({
      x: {
        y: {
          'q.{r': {
            z: 'foo'
          }
        }
      }
    });
  });
  it('creates an object from a path with a right curly brace', function () {
    var newObj = {};

    dJSON.set(newObj, path.replace('{', ''), 'foo');
    expect(newObj).to.be.deep.equal({
      x: {
        y: {
          'q.r}': {
            z: 'foo'
          }
        }
      }
    });
  });
  it('creates an object from a path with curly braces', function () {
    var newObj = {};

    dJSON.set(newObj, path, 'foo');
    expect(newObj).to.be.deep.equal({
      x: {
        y: {
          'q.{r}': {
            z: 'foo'
          }
        }
      }
    });
  });
  it('creates an object from a path without curly braces', function () {
    var newObj = {};

    dJSON.set(newObj, path.replace('{', '').replace('}', ''), 'foo');
    expect(newObj).to.be.deep.equal({
      x: {
        y: {
          'q.r': {
            z: 'foo'
          }
        }
      }
    });
  });
});

var fusepm = require('./fusepm');

module.exports = fixunoproj;

function fixunoproj () {
	var fn = fusepm.local_unoproj(".");
	fusepm.read_unoproj(fn).then(function (obj) {
		var inc = [];
		if (obj.Includes) {
			var re = /\//;
			for (var i=0; i<obj.Includes.length;i++) {
				if (obj.Includes[i] === '*') {
					inc.push('./*.ux');
					inc.push('./*.uno');
					inc.push('./*.uxl');
				}
				else if (!obj.Includes[i].match(re)) {
					inc.push('./' + obj.Includes[i]);
				}
				else {
					inc.push(obj.Includes[i]);
				}

			}
		}
		else {
			inc = ['./*.ux', './*.uno', './*.uxl'];
		}
		if (!obj.Version) {
			obj.Version = "0.0.0";
		}
		obj.Includes = inc;
		fusepm.save_unoproj(fn, obj);
	}).catch(function (e) {
		console.log(e);
	});
}
import mod437 from './mod437';
var value=mod437+1;
export default value;

const defaults = {

	base_css: true,						// the base dark theme css

	inline_youtube: true,				// makes youtube videos play inline the chat

	collapse_onebox: true, 				// can collapse

	collapse_onebox_default: false, 	// default option for collapse

	pause_youtube_on_collapse: true, 	// default option for pausing youtube on collapse

	user_color_bars: true,				// show colored bars above users message blocks

	fish_spinner: true,					// fish spinner is best spinner

	inline_imgur: true,					// inlines webm,gifv,mp4 content from imgur

	visualize_hex: true,				// underlines hex codes with their colour values

	syntax_highlight_code: true,		// guess at language and highlight the code blocks

	emoji_translator: true,				// emoji translator for INPUT area

	code_mode_editor: true,				// uses CodeMirror for your code inputs

	better_image_uploads: true			// use the drag & drop and paste api for image uploads

};

const fileLocations = {
	inline_youtube: ['js/inline_youtube.js'],
	collapse_onebox: ['js/collapse_onebox.js'],
	user_color_bars: ['js/user_color_bars.js'],
	fish_spinner: ['js/fish_spinner.js'],
	inline_imgur: ['js/inline_imgur.js'],
	visualize_hex: ['js/visualize_hex.js'],
	better_image_uploads: ['js/better_image_uploads.js'],
	syntax_highlight_code: ['js/highlight.js', 'js/syntax_highlight_code.js'],
	emoji_translator: ['js/emojidata.js', 'js/emoji_translator.js'],
	code_mode_editor: ['CodeMirror/js/codemirror.js',
						'CodeMirror/mode/cmake/cmake.js',
						'CodeMirror/mode/cobol/cobol.js',
						'CodeMirror/mode/coffeescript/coffeescript.js',
						'CodeMirror/mode/commonlisp/commonlisp.js',
						'CodeMirror/mode/css/css.js',
						'CodeMirror/mode/dart/dart.js',
						'CodeMirror/mode/go/go.js',
						'CodeMirror/mode/groovy/groovy.js',
						'CodeMirror/mode/haml/haml.js',
						'CodeMirror/mode/haskell/haskell.js',
						'CodeMirror/mode/htmlembedded/htmlembedded.js',
						'CodeMirror/mode/htmlmixed/htmlmixed.js',
						'CodeMirror/mode/jade/jade.js',
						'CodeMirror/mode/javascript/javascript.js',
						'CodeMirror/mode/lua/lua.js',
						'CodeMirror/mode/markdown/markdown.js',
						'CodeMirror/mode/mathematica/mathematica.js',
						'CodeMirror/mode/nginx/nginx.js',
						'CodeMirror/mode/pascal/pascal.js',
						'CodeMirror/mode/perl/perl.js',
						'CodeMirror/mode/php/php.js',
						'CodeMirror/mode/puppet/puppet.js',
						'CodeMirror/mode/python/python.js',
						'CodeMirror/mode/ruby/ruby.js',
						'CodeMirror/mode/sass/sass.js',
						'CodeMirror/mode/scheme/scheme.js',
						'CodeMirror/mode/shell/shell.js' ,
						'CodeMirror/mode/sql/sql.js',
						'CodeMirror/mode/swift/swift.js',
						'CodeMirror/mode/twig/twig.js',
						'CodeMirror/mode/vb/vb.js',
						'CodeMirror/mode/vbscript/vbscript.js',
						'CodeMirror/mode/vhdl/vhdl.js',
						'CodeMirror/mode/vue/vue.js',
						'CodeMirror/mode/xml/xml.js',
						'CodeMirror/mode/xquery/xquery.js',
						'CodeMirror/mode/yaml/yaml.js',
						'js/code_mode_editor.js']
};


// right now I assume order is correct because I'm a terrible person. make an order array or base it on File Locations and make that an array

// inject the observer and the utils always. then initialize the options.
injector([{type: 'js', location: 'js/observer.js'},{type: 'js', location: 'js/utils.js'}], _ => chrome.storage.sync.get(defaults, init));

function init(options) {
	// inject the options for the plugins themselves.
	const opts = document.createElement('script');
	opts.textContent = `
		const options = ${JSON.stringify(options)};
	`;
	document.body.appendChild(opts);
	// now load the plugins.
	const loading = [];
	if( !options.base_css ) {
		document.documentElement.classList.add('nocss');
	}
	delete options.base_css;
	for( const key of Object.keys(options) ) {
		if( !options[key] || !( key in fileLocations)) continue;
		for( const location of fileLocations[key] ) {
			const [,type] = location.split('.');
			loading.push({location, type});
		}
	}
	injector(loading, _ => {
		const drai = document.createElement('script');
		drai.textContent = `
		if( document.readyState === 'complete' ) {
			DOMObserver.drain();
		} else {
			window.onload = _ => DOMObserver.drain();
		}
		`;
		document.body.appendChild(drai);
	});
}

function injector([first, ...rest], cb) {
	if( !first ) return cb();
	if( first.type === 'js' ) {
		injectJS(first.location, _ => injector(rest, cb));
	} else {
		injectCSS(first.location, _ => injector(rest, cb));
	}
}

function injectCSS(file, cb) {
	const elm = document.createElement('link');
	elm.rel = 'stylesheet';
	elm.type = 'text/css';
	elm.href = chrome.extension.getURL(file);
	elm.onload = cb;
	document.head.appendChild(elm);
}

function injectJS(file, cb) {
	const elm = document.createElement('script');
	elm.type = 'text/javascript';
	elm.src = chrome.extension.getURL(file);
	elm.onload = cb;
	document.body.appendChild(elm);
}
'use strict';

const expect = require('expect.js');
const http = require('http');
const express = require('express');
const linkCheck = require('../');

describe('link-check', function () {

    this.timeout(2500);//increase timeout to enable 429 retry tests

    let baseUrl;
    let laterCustomRetryCounter;

    before(function (done) {
        const app = express();

        app.head('/nohead', function (req, res) {
            res.sendStatus(405); // method not allowed
        });
        app.get('/nohead', function (req, res) {
            res.sendStatus(200);
        });

        app.get('/foo/redirect', function (req, res) {
            res.redirect('/foo/bar');
        });
        app.get('/foo/bar', function (req, res) {
            res.json({foo:'bar'});
        });

        app.get('/loop', function (req, res) {
            res.redirect('/loop');
        });

        app.get('/hang', function (req, res) {
            // no reply
        });

        app.get('/notfound', function (req, res) {
            res.sendStatus(404);
        });

        app.get('/basic-auth', function (req, res) {

            if (req.headers["authorization"] === "Basic Zm9vOmJhcg==") {
                return res.sendStatus(200);
            }
            res.sendStatus(401);
        });

        // prevent first header try to be a hit
        app.head('/later-custom-retry-count', function (req, res) {
            res.sendStatus(405); // method not allowed
        });
        app.get('/later-custom-retry-count', function (req, res) {
            laterCustomRetryCounter++;

            if(laterCustomRetryCounter === parseInt(req.query.successNumber)) {
                res.sendStatus(200);
            }else{
              res.setHeader('retry-after', 1);
              res.sendStatus(429);
            }
        });

        // prevent first header try to be a hit
        app.head('/later-standard-header', function (req, res) {
            res.sendStatus(405); // method not allowed
        });
        var stdRetried = false;
        var stdFirstTry = 0;
        app.get('/later', function (req, res) {
            var isRetryDelayExpired = stdFirstTry + 1000 < Date.now();
            if(!stdRetried || !isRetryDelayExpired){
              stdFirstTry = Date.now();
              stdRetried = true;
              res.setHeader('retry-after', 1);
              res.sendStatus(429);
            }else{
              res.sendStatus(200);
            }
        });

        // prevent first header try to be a hit
        app.head('/later-no-header', function (req, res) {
            res.sendStatus(405); // method not allowed
        });
        var stdNoHeadRetried = false;
        var stdNoHeadFirstTry = 0;
        app.get('/later-no-header', function (req, res) {
            var minTime = stdNoHeadFirstTry + 1000;
            var maxTime = minTime + 100;
            var now = Date.now();
            var isRetryDelayExpired = minTime < now && now < maxTime;
            if(!stdNoHeadRetried || !isRetryDelayExpired){
              stdNoHeadFirstTry = Date.now();
              stdNoHeadRetried = true;
              res.sendStatus(429);
            }else{
              res.sendStatus(200);
            }
        });

        // prevent first header try to be a hit
        app.head('/later-non-standard-header', function (req, res) {
            res.sendStatus(405); // method not allowed
        });
        var nonStdRetried = false;
        var nonStdFirstTry = 0;
        app.get('/later-non-standard-header', function (req, res) {
            var isRetryDelayExpired = nonStdFirstTry + 1000 < Date.now();
            if(!nonStdRetried || !isRetryDelayExpired){
              nonStdFirstTry = Date.now();
              nonStdRetried = true;
              res.setHeader('retry-after', '1s');
              res.sendStatus(429);
            }else {
              res.sendStatus(200);
            }
        });

        app.get(encodeURI('/url_with_unicode–'), function (req, res) {
            res.sendStatus(200);
        });

        app.get('/url_with_special_chars\\(\\)\\+', function (req, res) {
            res.sendStatus(200);
        });

        const server = http.createServer(app);
        server.listen(0 /* random open port */, 'localhost', function serverListen(err) {
            if (err) {
                done(err);
                return;
            }
            baseUrl = 'http://' + server.address().address + ':' + server.address().port;
            done();
        });
    });

    it('should find that a valid link is alive', function (done) {
        linkCheck(baseUrl + '/foo/bar', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/foo/bar');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            expect(result.err).to.be(null);
            done();
        });
    });

    it('should find that a valid external link with basic authentication is alive', function (done) {
        linkCheck(baseUrl + '/basic-auth', {
            headers: {
                'Authorization': 'Basic Zm9vOmJhcg=='
            },
        }, function (err, result) {
            expect(err).to.be(null);
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            expect(result.err).to.be(null);
            done();
        });
    });

    it('should find that a valid relative link is alive', function (done) {
        linkCheck('/foo/bar', { baseUrl: baseUrl }, function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be('/foo/bar');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            expect(result.err).to.be(null);
            done();
        });
    });

    it('should find that an invalid link is dead', function (done) {
        linkCheck(baseUrl + '/foo/dead', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/foo/dead');
            expect(result.status).to.be('dead');
            expect(result.statusCode).to.be(404);
            expect(result.err).to.be(null);
            done();
        });
    });

    it('should find that an invalid relative link is dead', function (done) {
        linkCheck('/foo/dead', { baseUrl: baseUrl }, function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be('/foo/dead');
            expect(result.status).to.be('dead');
            expect(result.statusCode).to.be(404);
            expect(result.err).to.be(null);
            done();
        });
    });

    it('should report no DNS entry as a dead link (http)', function (done) {
        linkCheck('http://example.example.example.com/', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be('http://example.example.example.com/');
            expect(result.status).to.be('dead');
            expect(result.statusCode).to.be(0);
            expect(result.err.code).to.be('ENOTFOUND');
            done();
        });
    });

    it('should report no DNS entry as a dead link (https)', function (done) {
        const badLink = 'https://githuuuub.com/tcort/link-check';
        linkCheck(badLink, function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(badLink);
            expect(result.status).to.be('dead');
            expect(result.statusCode).to.be(0);
            expect(result.err.code).to.contain('ENOTFOUND');
            done();
        });
    });

    it('should timeout if there is no response', function (done) {
        linkCheck(baseUrl + '/hang', { timeout: '100ms' }, function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/hang');
            expect(result.status).to.be('dead');
            expect(result.statusCode).to.be(0);
            expect(result.err.code).to.be('ECONNRESET');
            done();
        });
    });

    it('should try GET if HEAD fails', function (done) {
        linkCheck(baseUrl + '/nohead', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/nohead');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            expect(result.err).to.be(null);
            done();
        });
    });

    it('should handle redirects', function (done) {
        linkCheck(baseUrl + '/foo/redirect', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/foo/redirect');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            expect(result.err).to.be(null);
            done();
        });
    });

    it('should handle valid mailto', function (done) {
        linkCheck('mailto:linuxgeek@gmail.com', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be('mailto:linuxgeek@gmail.com');
            expect(result.status).to.be('alive');
            done();
        });
    });

    it('should handle valid mailto with encoded characters in address', function (done) {
        linkCheck('mailto:foo%20bar@example.org', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be('mailto:foo%20bar@example.org');
            expect(result.status).to.be('alive');
            done();
        });
    });

    it('should handle valid mailto containing hfields', function (done) {
        linkCheck('mailto:linuxgeek@gmail.com?subject=caf%C3%A9', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be('mailto:linuxgeek@gmail.com?subject=caf%C3%A9');
            expect(result.status).to.be('alive');
            done();
        });
    });

    it('should handle invalid mailto', function (done) {
        linkCheck('mailto:foo@@bar@@baz', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be('mailto:foo@@bar@@baz');
            expect(result.status).to.be('dead');
            done();
        });
    });

    it('should handle file protocol', function(done) {
        linkCheck('fixtures/file.md', { baseUrl: 'file://' + __dirname }, function(err, result) {
            expect(err).to.be(null);

            expect(result.err).to.be(null);
            expect(result.status).to.be('alive');
            done()
        });
    });

    it('should handle file protocol with fragment', function(done) {
        linkCheck('fixtures/file.md#section-1', { baseUrl: 'file://' + __dirname }, function(err, result) {
            expect(err).to.be(null);

            expect(result.err).to.be(null);
            expect(result.status).to.be('alive');
            done()
        });
    });

    it('should handle file protocol with query', function(done) {
        linkCheck('fixtures/file.md?foo=bar', { baseUrl: 'file://' + __dirname }, function(err, result) {
            expect(err).to.be(null);

            expect(result.err).to.be(null);
            expect(result.status).to.be('alive');
            done()
        });
    });

    it('should handle file path containing spaces', function(done) {
        linkCheck('fixtures/s p a c e/A.md', { baseUrl: 'file://' + __dirname }, function(err, result) {
            expect(err).to.be(null);

            expect(result.err).to.be(null);
            expect(result.status).to.be('alive');
            done()
        });
    });

    it('should handle baseUrl containing spaces', function(done) {
        linkCheck('A.md', { baseUrl: 'file://' + __dirname + '/fixtures/s p a c e'}, function(err, result) {
            expect(err).to.be(null);

            expect(result.err).to.be(null);
            expect(result.status).to.be('alive');
            done()
        });
    });

    it('should handle file protocol and invalid files', function(done) {
        linkCheck('fixtures/missing.md', { baseUrl: 'file://' + __dirname }, function(err, result) {
            expect(err).to.be(null);

            expect(result.err.code).to.be('ENOENT');
            expect(result.status).to.be('dead');
            done()
        });
    });

    it('should ignore file protocol on absolute links', function(done) {
        linkCheck(baseUrl + '/foo/bar', { baseUrl: 'file://' }, function(err, result) {
            expect(err).to.be(null);

            expect(result.link).to.be(baseUrl + '/foo/bar');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            expect(result.err).to.be(null);
            done()
        });
    });

    it('should ignore file protocol on fragment links', function(done) {
        linkCheck('#foobar', { baseUrl: 'file://' }, function(err, result) {
            expect(err).to.be(null);

            expect(result.link).to.be('#foobar');
            done()
        });
    });

    it('should callback with an error on unsupported protocol', function (done) {
        linkCheck('gopher://gopher/0/v2/vstat', function (err, result) {
            expect(result).to.be(null);
            expect(err).to.be.an(Error);
            done();
        });
    });

    it('should handle redirect loops', function (done) {
        linkCheck(baseUrl + '/loop', function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/loop');
            expect(result.status).to.be('dead');
            expect(result.statusCode).to.be(0);
            expect(result.err.message).to.contain('Max redirects reached');
            done();
        });
    });

    it('should honour response codes in opts.aliveStatusCodes[]', function (done) {
        linkCheck(baseUrl + '/notfound', { aliveStatusCodes: [ 404, 200 ] },  function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/notfound');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(404);
            done();
        });
    });

    it('should honour regexps in opts.aliveStatusCodes[]', function (done) {
        linkCheck(baseUrl + '/notfound', { aliveStatusCodes: [ 200, /^[45][0-9]{2}$/ ] },  function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/notfound');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(404);
            done();
        });
    });

    it('should honour opts.aliveStatusCodes[]', function (done) {
        linkCheck(baseUrl + '/notfound', { aliveStatusCodes: [ 200 ] },  function (err, result) {
            expect(err).to.be(null);
            expect(result.link).to.be(baseUrl + '/notfound');
            expect(result.status).to.be('dead');
            expect(result.statusCode).to.be(404);
            done();
        });
    });

    it('should retry after the provided delay on HTTP 429 with standard header', function (done) {
        linkCheck(baseUrl + '/later', { retryOn429: true },  function (err, result) {
            expect(err).to.be(null);
            expect(result.err).to.be(null);
            expect(result.link).to.be(baseUrl + '/later');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            done();
        });
    });

    it('should retry after the provided delay on HTTP 429 with non standard header, and return a warning', function (done) {
        linkCheck(baseUrl + '/later-non-standard-header', { retryOn429: true },  function (err, result) {
            expect(err).to.be(null);
            expect(result.err).not.to.be(null)
            expect(result.err).to.contain("Server returned a non standard \'retry-after\' header.");
            expect(result.link).to.be(baseUrl + '/later-non-standard-header');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            done();
        });
    });

    it('should retry after 1s delay on HTTP 429 without header', function (done) {
        linkCheck(baseUrl + '/later-no-header', { retryOn429: true, fallbackRetryDelay: '1s' },  function (err, result) {
            expect(err).to.be(null);
            expect(result.err).to.be(null);
            expect(result.link).to.be(baseUrl + '/later-no-header');
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            done();
        });
    });

    // 2 is default retry so test with custom 3
    it('should retry 3 times for 429 status codes', function(done) {
        laterCustomRetryCounter = 0;
        linkCheck(baseUrl + '/later-custom-retry-count?successNumber=3', { retryOn429: true, retryCount: 3 }, function(err, result) {
            expect(err).to.be(null);
            expect(result.err).to.be(null);
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            done();
        });
    });

    // See issue #23
    it('should handle non URL encoded unicode chars in URLs', function(done) {
        //last char is 	EN DASH
        linkCheck(baseUrl + '/url_with_unicode–', function(err, result) {
            expect(err).to.be(null);
            expect(result.err).to.be(null);
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            done();
        });
    });

    // See issues #34 and #40
    it('should not URL encode already encoded characters', function(done) {
        linkCheck(baseUrl + '/url_with_special_chars%28%29%2B', function(err, result) {
            expect(err).to.be(null);
            expect(result.err).to.be(null);
            expect(result.status).to.be('alive');
            expect(result.statusCode).to.be(200);
            done();
        });
    });

});

function daysLeftThisWeek (date) {
  return 6 - date.getDay()
}

module.exports = daysLeftThisWeek

async function test(object) {
  for (var key in object) {
    await key;
  }
}

var contenedor = {};
var json = [];
var json_active = [];
var timeout;
var result = {};

$(document).ready(function() {

    $('#buscador').keyup(function() {  
        if (timeout) {    
            clearTimeout(timeout);    
            timeout = null;  
        }

          
        timeout = setTimeout(function() {
            search();
        }, 100);
    });


    $("body").on('change', '#result', function() {
        result = $("#result").val();
        load_content(json);
    });

    $("body").on('click', '.asc', function() {
        var name = $(this).parent().attr('rel');
        console.log(name);
        $(this).removeClass("asc").addClass("desc");
        order(name, true);
    });

    $("body").on('click', '.desc', function() {
        var name = $(this).parent().attr('rel');
        $(this).removeClass("desc").addClass("asc");
        order(name, false);
    });

});

function update(id,parent,valor){
    for (var i=0; i< json.length; i++) {
        if (json[i].id === id){
            json[i][parent] = valor;
            return;
        }
    }
}

function load_content(json) {

    max = result;
    data = json.slice(0, max);
    json_active = json;
    $("#numRows").html(json.length);
    contenedor.html('');
    2

    var list = table.find("th[rel]");
    var html = '';

    $.each(data, function(i, value) {
        html += '<tr id="' + value.id + '">';
        $.each(list, function(index) {

            valor = $(this).attr('rel');

            if (valor != 'acction') {
                if ($(this).hasClass("editable")) {
                    html += '<td><span class="edition" rel="' + value.id + '">' +  value[valor] .substring(0, 60) +'</span></td>';
                } else if($(this).hasClass("view")){
                    if(value[valor].length > 1){
                        var class_1 = $(this).data('class');
                        html += '<td><a  href="javascript:void(0)" class="'+class_1+'" rel="'+ value[valor] + '" data-id="' + value.id + '"></a></td>';
                    }else{
                         html += '<td></td>';
                    }
                   
                }else{
                    html += '<td>' + value[valor] + '</td>';
                }

            } else {

                html += '<td>';
                $.each(acction, function(k, data) {
                    html += '<a class="' + data.class + '" rel="' + value[data.rel] + '" href="' + data.link + value[data.parameter] + '"  target="'+data.target+'" >' + data.button + '</a>';
                });
                html += "</td>";
            }

            if (index >= list.length - 1) {
                html += '</tr>';
                contenedor.append(html);
                html = '';
            }
        });
    });

}

function selectedRow(json) {

    var num = result;
    var rows = json.length;
    var total = rows / num;
    var cant = Math.floor(total);
    $("#result").html('');
    for (i = 0; i < cant; i++) {
        $("#result").append("<option value=\"" + parseInt(num) + "\">" + num + "</option>");
        num = num + result;
    }
    $("#result").append("<option value=\"" + parseInt(rows) + "\">" + rows + "</option>");

}

function order(prop, asc) {
    json = json.sort(function(a, b) {
        if (asc) return (a[prop] > b[prop]) ? 1 : ((a[prop] < b[prop]) ? -1 : 0);
        else return (b[prop] > a[prop]) ? 1 : ((b[prop] < a[prop]) ? -1 : 0);
    });
    contenedor.html('');
    load_content(json);
}


function search() {

    var list = table.find("th[rel]");
    var data = [];
    var serch = $("#buscador").val();

    json.forEach(function(element, index, array) {

        $.each(list, function(index) {
            valor = $(this).attr('rel');

            if (element[valor]) {
                if (element[valor].like('%' + serch + '%')) {
                    data.push(element);
                    return false;
                }
            }

        });

    });

    contenedor.html('');
    load_content(data);

}

String.prototype.like = function(search) {

    if (typeof search !== 'string' || this === null) {
        return false;
    }
    search = search.replace(new RegExp("([\\.\\\\\\+\\*\\?\\[\\^\\]\\$\\(\\)\\{\\}\\=\\!\\<\\>\\|\\:\\-])", "g"), "\\$1");
    search = search.replace(/%/g, '.*').replace(/_/g, '.');
    return RegExp('^' + search + '$', 'gi').test(this);
}


function export_csv(JSONData, ReportTitle, ShowLabel) {
    var arrData = typeof JSONData != 'object' ? JSON.parse(JSONData) : JSONData;
    
    var CSV = '';    
    
 //   CSV += ReportTitle + '\r\n\n';

    if (ShowLabel) {
        var row = "";

        for (var index in arrData[0]) {

            row += index + ';';
        }

        row = row.slice(0, -1);

        CSV += row + '\r\n';
    }

    for (var i = 0; i < arrData.length; i++) {
        var row = "";

        for (var index in arrData[i]) {
            row += '"' + arrData[i][index] + '";';
        }
        row.slice(0, row.length - 1);
        CSV += row + '\r\n';
    }

    if (CSV == '') {        
        alert("Invalid data");
        return;
    }   
 //   var fileName = "Report_";
//fileName += ReportTitle.replace(/ /g,"_");   
    var uri = 'data:text/csv;charset=utf-8,' + escape(CSV);
    var link = document.createElement("a");    
    link.href = uri;
    link.style = "visibility:hidden";
    link.download = ReportTitle + ".csv";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
import React from 'react';
import ons from 'onsenui';

import {
  Page,
  Toolbar,
  BackButton,
  LazyList,
  ListItem
} from 'react-onsenui';

class InfiniteScroll extends React.Component {
  renderRow(index) {
    return (
      <ListItem key={index}>
        {'Item ' + (index + 1)}
      </ListItem>
    );
  }

  renderToolbar() {
    return (
      <Toolbar>
        <div className='left'>
          <BackButton>Back</BackButton>
        </div>
        <div className='center'>
          Infinite scroll
        </div>
      </Toolbar>
    );
  }

  render() {
    return (
      <Page renderToolbar={this.renderToolbar}>
        <LazyList
          length={10000}
          renderRow={this.renderRow}
          calculateItemHeight={() => ons.platform.isAndroid() ? 77 : 45}
        />
      </Page>
    );
  }
}

module.exports = InfiniteScroll;

$js.module({
prerequisite:[
	'/{$jshome}/modules/splice.module.extensions.js'
],
imports:[
	{ Inheritance : '/{$jshome}/modules/splice.inheritance.js' },
	{'SpliceJS.UI':'../splice.ui.js'},
	'splice.controls.pageloader.html'
],
definition:function(){
	var scope = this;

	var
		imports = scope.imports
	;

	var
		Class = imports.Inheritance.Class
	,	UIControl = imports.SpliceJS.UI.UIControl
	;


	var PageLoader = Class(function PageLoaderController(){
		this.base();
	}).extend(UIControl);


    scope.exports(
        PageLoader
    );

}
})

'use babel';

import MapQueries from '../lib/map-queries';

// Use the command `window:run-package-specs` (cmd-alt-ctrl-p) to run specs.
//
// To run a specific `it` or `describe` block add an `f` to the front (e.g. `fit`
// or `fdescribe`). Remove the `f` to unfocus the block.

describe('MapQueries', () => {
  let workspaceElement, activationPromise;

  beforeEach(() => {
    workspaceElement = atom.views.getView(atom.workspace);
    activationPromise = atom.packages.activatePackage('map-queries');
  });

  describe('when the map-queries:toggle event is triggered', () => {
    it('hides and shows the modal panel', () => {
      // Before the activation event the view is not on the DOM, and no panel
      // has been created
      expect(workspaceElement.querySelector('.map-queries')).not.toExist();

      // This is an activation event, triggering it will cause the package to be
      // activated.
      atom.commands.dispatch(workspaceElement, 'map-queries:toggle');

      waitsForPromise(() => {
        return activationPromise;
      });

      runs(() => {
        expect(workspaceElement.querySelector('.map-queries')).toExist();

        let mapQueriesElement = workspaceElement.querySelector('.map-queries');
        expect(mapQueriesElement).toExist();

        let mapQueriesPanel = atom.workspace.panelForItem(mapQueriesElement);
        expect(mapQueriesPanel.isVisible()).toBe(true);
        atom.commands.dispatch(workspaceElement, 'map-queries:toggle');
        expect(mapQueriesPanel.isVisible()).toBe(false);
      });
    });

    it('hides and shows the view', () => {
      // This test shows you an integration test testing at the view level.

      // Attaching the workspaceElement to the DOM is required to allow the
      // `toBeVisible()` matchers to work. Anything testing visibility or focus
      // requires that the workspaceElement is on the DOM. Tests that attach the
      // workspaceElement to the DOM are generally slower than those off DOM.
      jasmine.attachToDOM(workspaceElement);

      expect(workspaceElement.querySelector('.map-queries')).not.toExist();

      // This is an activation event, triggering it causes the package to be
      // activated.
      atom.commands.dispatch(workspaceElement, 'map-queries:toggle');

      waitsForPromise(() => {
        return activationPromise;
      });

      runs(() => {
        // Now we can test for view visibility
        let mapQueriesElement = workspaceElement.querySelector('.map-queries');
        expect(mapQueriesElement).toBeVisible();
        atom.commands.dispatch(workspaceElement, 'map-queries:toggle');
        expect(mapQueriesElement).not.toBeVisible();
      });
    });
  });
});
